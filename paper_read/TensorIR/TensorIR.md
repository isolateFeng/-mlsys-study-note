## TensorIR

第六页：相关工作

Halide 和 TVM 使用一种调度语言，可以用标量体描述循环嵌套的循环优化原语。 Tensor Comprehensions 、MLIR/Affine 使用多面体模型 来分析循环嵌套依赖性。以自下而上的方式使用标量计算优化循环嵌套

Fireiron和 Stripe使用嵌套多面体结构以自上而下的方式对张量程序建模。

TensorIR 结合了两种方法的见解，并将表示概括为张量化程序。

>   自动化是机器学习编译和张量程序优化中的一个重要主题。 AutoTVM [10] 引入了一种基于学习的方法，通过学习成本模型和模板引导搜索来优化张量程序。 Triton [41] 引入了一种基于图块的模板表示，用于有效的程序优化。 FlexTensor [50] 自动生成模板。 Halide 使用 Monte-Carlo 树搜索 [2] 构建了一个自动调度程序。 Ansor [48] 使用分层搜索空间改进了自动调度。 我们的自动调度算法从这些方法中吸取教训，并将它们推广到最适合特定领域硬件加速的张量化计算。 自动矢量化 [25, 36] 是编译器研究中的一个长期课题。 张量化可以被视为矢量化问题的推广，以启用现代加速器中的固有张量 [4、21、30、31]。 关于这个主题有一些现有的作品[6,45,47,49]。 AKG [47] 使用多面体方法探索张量化搜索空间，UNIT [45] 引入了一个通用的张量化流程，而 AMOS [49] 可以通过张量表达式自动映射到张量化内在。 我们的方法通过提出一种新的张量化计算抽象并联合执行张量化和其他优化来概括这些先前的方法。 TensorIR 是进一步开发张量感知自动调度方法的基础。



第七页

一个block可以包含一个或者多个nested loop nests，其中包含与计算内容相对应的子块  -->

允许我们将计算划分到相应的子块，并利用块签名来表示依赖（约束）关系



第11页

TensorIR以TVM IRModule为载体，从TVMScript中导入，并且可以不断进行Schedule变换，以及Pass变换，最终将优化后的IRModule build成为一个能够在不同硬件上运行的Module。

在Schedule变换过程中，对于给定的输入程序，我们需要生成具有等效语义的程序的丰富搜索空间。 我们引入原语将 TensorIR 程序转换为等效的优化程序。



第15页

对于每个输入的tensor指令，本文使用一种TensorIntrin结构，由两个块组成，一个块描述计算语义，另一个块提供张量化计算的底层实现。

通过TensorIntrin中的多维缓冲区规范包括数据类型、存储范围、内存布局和邻接约束。这些约束在验证阶段被使用。



第16页

（1）给定一对后端目标和一个输入程序，我们首先将程序主体与可能的TensorIntrin进行匹配，生成张量化候选对象。匹配以循序渐进的方式进行。

（2）系统将缓冲区访问表达式转换为中间迭代器。基于缓冲区访问模式，我们为每个迭代器计算特征函数，并在共享相同特征向量的迭代器之间建立映射。该映射进一步指导块实例空间和重建索引缓冲区的转换。



第17页

对于一组给定的张量候选者，我们需要构建一个包含tensorization的大型程序搜索空间，本文通过生成包含张量化计算的程序草图来构建搜索空间。

通过迭代应用预定义的草图生成规则来生成草图，需要检查块签名来构建适用于张量计算的草图生成规则，并在我们的分析过程中利用访问区域信息。

数据移动决策通常取决于计算调度决策，如平铺、线程绑定、执行范围和生产者-消费者数据流粒度。



第18页

在张量化程序草图生成阶段之后,我们使用进化搜索来探索空间并找到优化的张量程序。

初始化是随机选择一个程序草图，进化搜索由一个learning-base cost model指导

cost model使用从程序中提取的特征。 特征向量包含与内存访问模式、重用和循环注释相关的信息。（memory access patterns, reuse, and loop annotations）



第19页

以探索内存分配策略为例：
Astra采取测量驱动的方法来选择相互冲突的内存分配策略，在探索每个分配之后，我们为每个分配构建最佳配置，然后比较它们的端到端时间。
Parallel：每个子节点都能被独立地探索并调优
Prefix-based：每次只探索一维，其他参数不变。（第一个epoch搜索，找到ideal stream mapping；freeze the configuration；下一个epoch继续探索）
Exhaustive：详细地探索子树（指数级别复杂度）
Equivalence：如果一组kernel是同样的shape，在DFG中有着相似的inbound、outbound和depencies，那么它们可以同等看待
（10个GEMM kernel分给2个stream，有5中而不是2^10次种）
